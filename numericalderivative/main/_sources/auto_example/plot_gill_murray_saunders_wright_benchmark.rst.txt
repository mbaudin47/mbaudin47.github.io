
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_example/plot_gill_murray_saunders_wright_benchmark.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_example_plot_gill_murray_saunders_wright_benchmark.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_example_plot_gill_murray_saunders_wright_benchmark.py:


Benchmark Gill, Murray, Saunders and Wright method
==================================================

The goal of this example is to benchmark the :class:`~numericalderivative.GillMurraySaundersWright`
on a collection of test problems.
These problems are created by the :meth:`~numericalderivative.build_benchmark()` 
static method, which returns a list of problems.

References
----------
- Gill, P. E., Murray, W., Saunders, M. A., & Wright, M. H. (1983). Computing forward-difference intervals for numerical optimization. SIAM Journal on Scientific and Statistical Computing, 4(2), 310-321.

.. GENERATED FROM PYTHON SOURCE LINES 19-74

.. code-block:: Python

    import numpy as np
    import pylab as pl
    import tabulate
    import numericalderivative as nd


    class GillMurraySaundersWrightMethod:
        def __init__(self, relative_precision, kmin, kmax):
            """
            Create a GillMurraySaundersWright method to compute the approximate first derivative

            Parameters
            ----------
            relative_precision : float, > 0, optional
                The relative precision of evaluation of f.
            kmin : float, kmin > 0
                A minimum bound for the finite difference step of the third derivative.
                If no value is provided, the default is to compute the smallest
                possible kmin using number_of_digits and x.
            kmax : float, kmax > kmin > 0
                A maximum bound for the finite difference step of the third derivative.
                If no value is provided, the default is to compute the largest
                possible kmax using number_of_digits and x.
            """
            self.relative_precision = relative_precision
            self.kmin = kmin
            self.kmax = kmax

        def compute_first_derivative(self, function, x):
            """
            Compute the first derivative using GillMurraySaundersWright

            Parameters
            ----------
            function : function
                The function
            x : float
                The test point

            Returns
            -------
            f_prime_approx : float
                The approximate value of the first derivative of the function at point x
            number_of_function_evaluations : int
                The number of function evaluations.
            """
            algorithm = nd.GillMurraySaundersWright(
                function, x, relative_precision=self.relative_precision
            )
            step, _ = algorithm.compute_step(kmin, kmax)
            f_prime_approx = algorithm.compute_first_derivative(step)
            number_of_function_evaluations = algorithm.get_number_of_function_evaluations()
            return f_prime_approx, number_of_function_evaluations









.. GENERATED FROM PYTHON SOURCE LINES 75-77

The next example computes the approximate derivative on the
:class:`~numericalderivative.ExponentialProblem`.

.. GENERATED FROM PYTHON SOURCE LINES 79-101

.. code-block:: Python

    print("+ Benchmark on several points")
    number_of_test_points = 20
    kmin = 1.0e-16
    kmax = 1.0e-1
    problem = nd.ExponentialProblem()
    print(problem)
    interval = problem.get_interval()
    test_points = np.linspace(interval[0], interval[1], number_of_test_points)
    relative_precision = 1.0e-16
    method = GillMurraySaundersWrightMethod(relative_precision, kmin, kmax)
    average_relative_error, average_feval, data = nd.benchmark_method(
        problem.get_function(),
        problem.get_first_derivative(),
        test_points,
        method.compute_first_derivative,
        True,
    )
    print("Average relative error =", average_relative_error)
    print("Average number of function evaluations =", average_feval)
    tabulate.tabulate(data, headers=["x", "Rel. err.", "F. Eval."], tablefmt="html")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    + Benchmark on several points
    DerivativeBenchmarkProblem
    name = exp
    x = 1.0
    f(x) = 2.718281828459045
    f'(x) = 2.718281828459045
    f''(x) = 2.718281828459045
    f^(3)(x) = 2.718281828459045
    f^(4)(x) = 2.718281828459045
    f^(5)(x) = 2.718281828459045

    x = 0.000, abs. error = 7.834e-09, rel. error = 7.834e-09, Func. eval. = 16
    x = 0.632, abs. error = 1.490e-08, rel. error = 7.923e-09, Func. eval. = 16
    x = 1.263, abs. error = 2.406e-08, rel. error = 6.803e-09, Func. eval. = 16
    x = 1.895, abs. error = 7.543e-08, rel. error = 1.134e-08, Func. eval. = 16
    x = 2.526, abs. error = 9.082e-08, rel. error = 7.262e-09, Func. eval. = 16
    x = 3.158, abs. error = 3.543e-07, rel. error = 1.506e-08, Func. eval. = 16
    x = 3.789, abs. error = 5.208e-07, rel. error = 1.177e-08, Func. eval. = 16
    x = 4.421, abs. error = 9.058e-07, rel. error = 1.089e-08, Func. eval. = 16
    x = 5.053, abs. error = 2.098e-06, rel. error = 1.341e-08, Func. eval. = 16
    x = 5.684, abs. error = 3.223e-06, rel. error = 1.095e-08, Func. eval. = 16
    x = 6.316, abs. error = 9.323e-06, rel. error = 1.685e-08, Func. eval. = 16
    x = 6.947, abs. error = 7.871e-06, rel. error = 7.565e-09, Func. eval. = 16
    x = 7.579, abs. error = 1.835e-05, rel. error = 9.377e-09, Func. eval. = 16
    x = 8.211, abs. error = 3.103e-05, rel. error = 8.432e-09, Func. eval. = 16
    x = 8.842, abs. error = 5.438e-05, rel. error = 7.858e-09, Func. eval. = 16
    x = 9.474, abs. error = 8.491e-05, rel. error = 6.525e-09, Func. eval. = 16
    x = 10.105, abs. error = 1.934e-04, rel. error = 7.901e-09, Func. eval. = 16
    x = 10.737, abs. error = 3.913e-04, rel. error = 8.502e-09, Func. eval. = 16
    x = 11.368, abs. error = 5.613e-04, rel. error = 6.486e-09, Func. eval. = 16
    x = 12.000, abs. error = 2.590e-03, rel. error = 1.591e-08, Func. eval. = 16
    Average relative error = 9.933156858517556e-09
    Average number of function evaluations = 16.0


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
    <thead>
    <tr><th style="text-align: right;">        x</th><th style="text-align: right;">  Rel. err.</th><th style="text-align: right;">  F. Eval.</th></tr>
    </thead>
    <tbody>
    <tr><td style="text-align: right;"> 0       </td><td style="text-align: right;">7.8336e-09 </td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 0.631579</td><td style="text-align: right;">7.92349e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 1.26316 </td><td style="text-align: right;">6.8029e-09 </td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 1.89474 </td><td style="text-align: right;">1.13422e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 2.52632 </td><td style="text-align: right;">7.26172e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 3.15789 </td><td style="text-align: right;">1.50612e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 3.78947 </td><td style="text-align: right;">1.17732e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 4.42105 </td><td style="text-align: right;">1.08892e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 5.05263 </td><td style="text-align: right;">1.34107e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 5.68421 </td><td style="text-align: right;">1.09548e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 6.31579 </td><td style="text-align: right;">1.68514e-08</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 6.94737 </td><td style="text-align: right;">7.56484e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 7.57895 </td><td style="text-align: right;">9.37713e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 8.21053 </td><td style="text-align: right;">8.43229e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 8.84211 </td><td style="text-align: right;">7.85831e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;"> 9.47368 </td><td style="text-align: right;">6.52532e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;">10.1053  </td><td style="text-align: right;">7.9011e-09 </td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;">10.7368  </td><td style="text-align: right;">8.50247e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;">11.3684  </td><td style="text-align: right;">6.48593e-09</td><td style="text-align: right;">        16</td></tr>
    <tr><td style="text-align: right;">12       </td><td style="text-align: right;">1.59114e-08</td><td style="text-align: right;">        16</td></tr>
    </tbody>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 102-103

Map from the problem name to kmax

.. GENERATED FROM PYTHON SOURCE LINES 105-124

.. code-block:: Python

    kmax_map = {
        "polynomial": 1.0,
        "inverse": 1.0e0,
        "exp": 1.0e-1,
        "log": 1.0e-3,  # x > 0
        "sqrt": 1.0e-3,  # x > 0
        "atan": 1.0e0,
        "sin": 1.0e0,
        "scaled exp": 1.0e5,
        "GMSW": 1.0e0,
        "SXXN1": 1.0e0,
        "SXXN2": 1.0e0,  # Fails
        "SXXN3": 1.0e0,
        "SXXN4": 1.0e0,
        "Oliver1": 1.0e0,
        "Oliver2": 1.0e0,
        "Oliver3": 1.0e-3,
    }








.. GENERATED FROM PYTHON SOURCE LINES 125-127

Benchmark the :class:`~numericalderivative.GillMurraySaundersWright` class
on a collection of problems.

.. GENERATED FROM PYTHON SOURCE LINES 129-185

.. code-block:: Python

    number_of_test_points = 100
    relative_precision = 1.0e-15
    delta_x = 1.0e-9
    data = []
    function_list = nd.build_benchmark()
    number_of_functions = len(function_list)
    average_relative_error_list = []
    average_feval_list = []
    for i in range(number_of_functions):
        problem = function_list[i]
        function = problem.get_function()
        first_derivative = problem.get_first_derivative()
        name = problem.get_name()
        kmax = kmax_map[name]
        kmin = 1.0e-16 * kmax
        lower_x_bound, upper_x_bound = problem.get_interval()
        if name == "sin":
            # Change the lower and upper bound so that the points +/-pi
            # are excluded (see below for details).
            lower_x_bound += delta_x
            upper_x_bound -= delta_x
        test_points = np.linspace(lower_x_bound, upper_x_bound, number_of_test_points)
        print(f"Function #{i}, {name}")
        method = GillMurraySaundersWrightMethod(relative_precision, kmin, kmax)
        average_relative_error, average_feval, _ = nd.benchmark_method(
            function,
            first_derivative,
            test_points,
            method.compute_first_derivative,
        )
        average_relative_error_list.append(average_relative_error)
        average_feval_list.append(average_feval)
        data.append(
            (
                name,
                kmin,
                kmax,
                average_relative_error,
                average_feval,
            )
        )
    data.append(
        [
            "Average",
            "-",
            "-",
            np.nanmean(average_relative_error_list),
            np.nanmean(average_feval_list),
        ]
    )
    tabulate.tabulate(
        data,
        headers=["Name", "kmin", "kmax", "Average error", "Average func. eval"],
        tablefmt="html",
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Function #0, polynomial
    Function #1, inverse
    Function #2, exp
    Function #3, log
    Function #4, sqrt
    Function #5, atan
    Function #6, sin
    Function #7, scaled exp
    Function #8, GMSW
    Function #9, SXXN1
    Function #10, SXXN2
    Function #11, SXXN3
    Function #12, SXXN4
    Function #13, Oliver1
    Function #14, Oliver2
    Function #15, Oliver3


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
    <thead>
    <tr><th>Name      </th><th>kmin  </th><th>kmax    </th><th style="text-align: right;">  Average error</th><th style="text-align: right;">  Average func. eval</th></tr>
    </thead>
    <tbody>
    <tr><td>polynomial</td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    2.23087e-08</td><td style="text-align: right;">             16.96  </td></tr>
    <tr><td>inverse   </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    4.48797e-08</td><td style="text-align: right;">             16.88  </td></tr>
    <tr><td>exp       </td><td>1e-17 </td><td>0.1     </td><td style="text-align: right;">    3.16536e-08</td><td style="text-align: right;">             18     </td></tr>
    <tr><td>log       </td><td>1e-19 </td><td>0.001   </td><td style="text-align: right;">    3.94827e-08</td><td style="text-align: right;">             16.34  </td></tr>
    <tr><td>sqrt      </td><td>1e-19 </td><td>0.001   </td><td style="text-align: right;">    3.18116e-08</td><td style="text-align: right;">             16.38  </td></tr>
    <tr><td>atan      </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    1.22055e-07</td><td style="text-align: right;">             17.48  </td></tr>
    <tr><td>sin       </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    1.09185e-07</td><td style="text-align: right;">             16     </td></tr>
    <tr><td>scaled exp</td><td>1e-11 </td><td>100000.0</td><td style="text-align: right;">    3.16955e-08</td><td style="text-align: right;">             18     </td></tr>
    <tr><td>GMSW      </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    3.10702e-08</td><td style="text-align: right;">             18.28  </td></tr>
    <tr><td>SXXN1     </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    8.20049e-07</td><td style="text-align: right;">             17.22  </td></tr>
    <tr><td>SXXN2     </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    5.08006e-08</td><td style="text-align: right;">             12     </td></tr>
    <tr><td>SXXN3     </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    2.93358e-08</td><td style="text-align: right;">             16.12  </td></tr>
    <tr><td>SXXN4     </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    2.597e-08  </td><td style="text-align: right;">             16.2   </td></tr>
    <tr><td>Oliver1   </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    3.14977e-08</td><td style="text-align: right;">             18     </td></tr>
    <tr><td>Oliver2   </td><td>1e-16 </td><td>1.0     </td><td style="text-align: right;">    5.77814e-08</td><td style="text-align: right;">             16.78  </td></tr>
    <tr><td>Oliver3   </td><td>1e-19 </td><td>0.001   </td><td style="text-align: right;">    3.47391e-08</td><td style="text-align: right;">             17.08  </td></tr>
    <tr><td>Average   </td><td>-     </td><td>-       </td><td style="text-align: right;">    9.46447e-08</td><td style="text-align: right;">             16.7325</td></tr>
    </tbody>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 186-196

Notice that the method cannot perform correctly for the sin function
at the point
Indeed, this function is such that :math:`f''(x) = 0` if :math:`x = \pm \pi`.
In this case, the condition error is infinite and the method
cannot work.
Therefore, we make so that the points :math:`\pm \pi` are excluded from the benchmark.
The same problem appears at the point :math:`x = 0`.
This point is not included in the test set if the number of points is even
(e.g. with `number_of_test_points = 100`), but it might appear if the
number of test points is odd.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.061 seconds)


.. _sphx_glr_download_auto_example_plot_gill_murray_saunders_wright_benchmark.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_gill_murray_saunders_wright_benchmark.ipynb <plot_gill_murray_saunders_wright_benchmark.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_gill_murray_saunders_wright_benchmark.py <plot_gill_murray_saunders_wright_benchmark.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_gill_murray_saunders_wright_benchmark.zip <plot_gill_murray_saunders_wright_benchmark.zip>`
